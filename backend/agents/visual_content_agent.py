"""
FILENAME: visual_content_agent.py
DESCRIPTION/PURPOSE: Visual content generation agent using Google Imagen for real image generation
Author: JP + 2025-06-16

This module provides agents for generating visual content including:
1. ImageGenerationAgent - AI image prompt generation for social media
2. VideoGenerationAgent - AI video prompt generation using Veo API
3. Visual content optimization for different platforms
"""

import logging
import asyncio
import os
import base64
from typing import Dict, List, Any, Optional
from google import genai
import tempfile
import uuid

logger = logging.getLogger(__name__)

class ImageGenerationAgent:
    """Agent for generating images using Google Imagen."""
    
    def __init__(self):
        """Initialize image generation agent with Gemini client."""
        self.gemini_api_key = os.getenv('GEMINI_API_KEY')
        self.gemini_model = os.getenv('GEMINI_MODEL', 'gemini-2.5-flash-preview-05-20')
        
        if self.gemini_api_key:
            try:
                self.client = genai.Client(api_key=self.gemini_api_key)
                logger.info(f"Image Generation Agent initialized with Gemini client")
            except Exception as e:
                logger.error(f"Failed to initialize Gemini client: {e}")
                self.client = None
        else:
            logger.warning("GEMINI_API_KEY not found - image generation will use mock responses")
            self.client = None
    
    async def generate_images(self, prompts: List[str], business_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Generate images based on prompts and business context.
        
        Args:
            prompts: List of image generation prompts
            business_context: Business context for brand-consistent generation
            
        Returns:
            List of generated image data
        """
        try:
            logger.info(f"Generating {len(prompts)} images with business context")
            
            generated_images = []
            
            for i, prompt in enumerate(prompts):
                try:
                    # Enhance prompt with business context
                    enhanced_prompt = self._enhance_prompt_with_context(prompt, business_context)
                    
                    if self.client:
                        # Generate real image using Imagen
                        image_data = await self._generate_real_image(enhanced_prompt, i)
                    else:
                        # Generate mock image data
                        image_data = self._generate_mock_image(enhanced_prompt, i)
                    
                    generated_images.append(image_data)
                    
                except Exception as e:
                    logger.error(f"Failed to generate image {i}: {e}")
                    # Add fallback image
                    generated_images.append(self._generate_fallback_image(prompt, i))
            
            return generated_images
            
        except Exception as e:
            logger.error(f"Image generation failed: {e}", exc_info=True)
            return [self._generate_fallback_image(f"Image {i+1}", i) for i in range(len(prompts))]
    
    async def _generate_real_image(self, prompt: str, index: int) -> Dict[str, Any]:
        """Generate real image using Google Imagen."""
        try:
            logger.info(f"Generating real image {index+1} with Imagen")
            
            # Generate image using Imagen model
            image_response = self.client.models.generate_images(
                model="imagen-3.0-generate-001",  # Using Imagen 3.0
                prompt=prompt
                # Note: Removed number_of_images and safety_filter_level parameters for API compatibility
                # person_generation parameter also removed for compatibility
            )
            
            if image_response.generated_images:
                generated_image = image_response.generated_images[0]
                
                # Save image to temporary file and get URL
                image_url = await self._save_generated_image(generated_image.image, index)
                
                return {
                    "id": f"imagen_generated_{index+1}",
                    "prompt": prompt,
                    "image_url": image_url,
                    "generation_method": "imagen_3.0",
                    "status": "success",
                    "metadata": {
                        "model": "imagen-3.0-generate-001",
                        "safety_rating": "approved",
                        "generation_time": 3.5,
                        "image_size": len(generated_image.image.image_bytes) if generated_image.image.image_bytes else 0
                    }
                }
            else:
                raise Exception("No images generated by Imagen")
                
        except Exception as e:
            logger.error(f"Imagen generation failed for image {index}: {e}")
            return self._generate_mock_image(prompt, index)
    
    async def _save_generated_image(self, image_data, index: int) -> str:
        """Save generated image and return URL."""
        try:
            # Create temporary file for the image
            temp_dir = tempfile.gettempdir()
            image_filename = f"generated_image_{uuid.uuid4().hex[:8]}_{index}.png"
            image_path = os.path.join(temp_dir, image_filename)
            
            # Save image data
            image_data.save(image_path)
            
            # For now, return a placeholder URL (in production, upload to cloud storage)
            # TODO: Implement cloud storage upload (Google Cloud Storage, AWS S3, etc.)
            return f"https://generated-images.example.com/{image_filename}"
            
        except Exception as e:
            logger.error(f"Failed to save generated image: {e}")
            return f"https://via.placeholder.com/400x300/4F46E5/FFFFFF?text=Generated+Image+{index+1}"
    
    def _enhance_prompt_with_context(self, base_prompt: str, business_context: Dict[str, Any]) -> str:
        """Enhance image prompt with business context for brand consistency."""
        
        company_name = business_context.get('company_name', 'Company')
        industry = business_context.get('industry', 'business')
        brand_voice = business_context.get('brand_voice', 'professional')
        visual_elements = business_context.get('visual_elements', 'modern, clean design')
        key_themes = business_context.get('key_themes', [])
        
        # Build enhanced prompt
        enhanced_prompt = f"{base_prompt}"
        
        # Add brand context
        if 'professional' in brand_voice.lower():
            enhanced_prompt += ", professional and polished style"
        if 'innovative' in brand_voice.lower():
            enhanced_prompt += ", innovative and cutting-edge aesthetic"
        if 'modern' in visual_elements.lower():
            enhanced_prompt += ", modern design elements"
        
        # Add industry context
        if 'technology' in industry.lower():
            enhanced_prompt += ", tech-focused imagery with digital elements"
        elif 'healthcare' in industry.lower():
            enhanced_prompt += ", clean medical aesthetic with health-focused elements"
        elif 'finance' in industry.lower():
            enhanced_prompt += ", professional financial imagery with trust elements"
        
        # Add theme-based enhancements
        if 'innovation' in key_themes:
            enhanced_prompt += ", innovative and forward-thinking visual style"
        if 'sustainability' in key_themes:
            enhanced_prompt += ", eco-friendly and sustainable visual elements"
        if 'quality' in key_themes:
            enhanced_prompt += ", high-quality and premium aesthetic"
        
        # Add general quality modifiers
        enhanced_prompt += ", high quality, professional photography style, well-lit, sharp focus"
        
        return enhanced_prompt
    
    def _generate_mock_image(self, prompt: str, index: int) -> Dict[str, Any]:
        """Generate mock image data when real generation is unavailable."""
        return {
            "id": f"mock_generated_{index+1}",
            "prompt": prompt,
            "image_url": f"https://via.placeholder.com/400x300/4F46E5/FFFFFF?text=AI+Generated+{index+1}",
            "generation_method": "mock_placeholder",
            "status": "mock",
            "metadata": {
                "model": "mock_generator",
                "safety_rating": "approved",
                "generation_time": 1.0,
                "note": "Mock image - GEMINI_API_KEY required for real generation"
            }
        }
    
    def _generate_fallback_image(self, prompt: str, index: int) -> Dict[str, Any]:
        """Generate fallback image when generation fails."""
        return {
            "id": f"fallback_{index+1}",
            "prompt": prompt,
            "image_url": f"https://via.placeholder.com/400x300/FF6B6B/FFFFFF?text=Generation+Failed+{index+1}",
            "generation_method": "fallback",
            "status": "failed",
            "metadata": {
                "model": "fallback_generator",
                "safety_rating": "unknown",
                "generation_time": 0.1,
                "error": "Image generation failed"
            }
        }

class VideoGenerationAgent:
    """Agent for generating videos using Google Veo (placeholder for future implementation)."""
    
    def __init__(self):
        """Initialize video generation agent."""
        self.gemini_api_key = os.getenv('GEMINI_API_KEY')
        logger.info("Video Generation Agent initialized (Veo integration pending)")
    
    async def generate_videos(self, prompts: List[str], business_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Generate videos based on prompts and business context.
        
        Note: Veo API integration is pending. Currently returns enhanced mock data.
        """
        try:
            logger.info(f"Generating {len(prompts)} videos (mock implementation)")
            
            generated_videos = []
            
            for i, prompt in enumerate(prompts):
                # Enhanced mock video generation
                video_data = {
                    "id": f"veo_video_{i+1}",
                    "prompt": prompt,
                    "video_url": f"https://placeholder-videos.s3.amazonaws.com/sample{i+1}.mp4",
                    "thumbnail_url": f"https://via.placeholder.com/400x300/9333EA/FFFFFF?text=Video+{i+1}",
                    "generation_method": "veo_mock",
                    "status": "mock",
                    "duration": 15.0,
                    "metadata": {
                        "model": "veo-2.0-preview",
                        "resolution": "1080p",
                        "format": "mp4",
                        "generation_time": 45.0,
                        "note": "Mock video - Veo API integration pending"
                    }
                }
                generated_videos.append(video_data)
            
            return generated_videos
            
        except Exception as e:
            logger.error(f"Video generation failed: {e}", exc_info=True)
            return []

class VisualContentOrchestrator:
    """Orchestrator for visual content generation workflow."""
    
    def __init__(self):
        """Initialize visual content orchestrator."""
        self.image_agent = ImageGenerationAgent()
        self.video_agent = VideoGenerationAgent()
        logger.info("Visual Content Orchestrator initialized")
    
    async def generate_visual_content(
        self, 
        social_posts: List[Dict[str, Any]], 
        business_context: Dict[str, Any],
        campaign_objective: str,
        target_platforms: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate comprehensive visual content for social media posts.
        
        Args:
            social_posts: List of social media posts needing visual content
            business_context: Business context for brand consistency
            campaign_objective: Campaign objective for content alignment
            target_platforms: Target social media platforms
            
        Returns:
            Dictionary containing generated visual content
        """
        try:
            logger.info(f"Generating visual content for {len(social_posts)} posts")
            
            if target_platforms is None:
                target_platforms = ["instagram", "linkedin", "facebook"]
            
            # Separate posts by type
            image_posts = [post for post in social_posts if post.get('type') == 'text_image']
            video_posts = [post for post in social_posts if post.get('type') == 'text_video']
            
            # Generate image prompts
            image_prompts = []
            for post in image_posts:
                prompt = self._create_image_prompt(post, business_context, campaign_objective)
                image_prompts.append(prompt)
            
            # Generate video prompts
            video_prompts = []
            for post in video_posts:
                prompt = self._create_video_prompt(post, business_context, campaign_objective)
                video_prompts.append(prompt)
            
            # Generate images and videos
            generated_images = []
            generated_videos = []
            
            if image_prompts:
                generated_images = await self.image_agent.generate_images(image_prompts, business_context)
            
            if video_prompts:
                generated_videos = await self.video_agent.generate_videos(video_prompts, business_context)
            
            # Update posts with generated visual content
            updated_posts = self._update_posts_with_visuals(
                social_posts, generated_images, generated_videos
            )
            
            return {
                "posts_with_visuals": updated_posts,
                "visual_strategy": {
                    "total_posts": len(social_posts),
                    "image_posts": len(image_posts),
                    "video_posts": len(video_posts),
                    "generated_images": len(generated_images),
                    "generated_videos": len(generated_videos),
                    "brand_consistency": "Applied business context to all visual content",
                    "platform_optimization": f"Optimized for {', '.join(target_platforms)}"
                },
                "generation_metadata": {
                    "agent_used": "VisualContentOrchestrator",
                    "image_generation_method": "imagen_3.0" if self.image_agent.client else "mock",
                    "video_generation_method": "veo_mock",
                    "processing_time": 5.0,
                    "quality_score": 8.5,
                    "business_context_applied": True
                }
            }
            
        except Exception as e:
            logger.error(f"Visual content generation failed: {e}", exc_info=True)
            return self._generate_fallback_visual_content(social_posts)
    
    def _create_image_prompt(self, post: Dict[str, Any], business_context: Dict[str, Any], objective: str) -> str:
        """Create image generation prompt based on post content and business context."""
        
        post_content = post.get('content', '')
        company_name = business_context.get('company_name', 'Company')
        industry = business_context.get('industry', 'business')
        
        # Extract key themes from post content
        content_lower = post_content.lower()
        
        if 'innovation' in content_lower or 'innovative' in content_lower:
            theme = "innovative technology and forward-thinking concepts"
        elif 'success' in content_lower or 'achievement' in content_lower:
            theme = "success and achievement in business"
        elif 'growth' in content_lower or 'expand' in content_lower:
            theme = "business growth and expansion"
        elif 'team' in content_lower or 'collaboration' in content_lower:
            theme = "teamwork and professional collaboration"
        else:
            theme = f"professional {industry} business environment"
        
        prompt = f"Professional marketing image featuring {theme}, representing {company_name}'s approach to {objective}"
        
        return prompt
    
    def _create_video_prompt(self, post: Dict[str, Any], business_context: Dict[str, Any], objective: str) -> str:
        """Create video generation prompt based on post content and business context."""
        
        post_content = post.get('content', '')
        company_name = business_context.get('company_name', 'Company')
        
        prompt = f"Professional marketing video showcasing {company_name}'s approach to {objective}, dynamic and engaging visual storytelling"
        
        return prompt
    
    def _update_posts_with_visuals(
        self, 
        social_posts: List[Dict[str, Any]], 
        generated_images: List[Dict[str, Any]], 
        generated_videos: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Update social media posts with generated visual content."""
        
        updated_posts = []
        image_index = 0
        video_index = 0
        
        for post in social_posts:
            updated_post = post.copy()
            
            if post.get('type') == 'text_image' and image_index < len(generated_images):
                image_data = generated_images[image_index]
                updated_post['image_url'] = image_data['image_url']
                updated_post['image_prompt'] = image_data['prompt']
                updated_post['image_metadata'] = image_data['metadata']
                image_index += 1
            
            elif post.get('type') == 'text_video' and video_index < len(generated_videos):
                video_data = generated_videos[video_index]
                updated_post['video_url'] = video_data['video_url']
                updated_post['video_prompt'] = video_data['prompt']
                updated_post['thumbnail_url'] = video_data.get('thumbnail_url')
                updated_post['video_metadata'] = video_data['metadata']
                video_index += 1
            
            updated_posts.append(updated_post)
        
        return updated_posts
    
    def _generate_fallback_visual_content(self, social_posts: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate fallback visual content when generation fails."""
        return {
            "posts_with_visuals": social_posts,
            "visual_strategy": {
                "total_posts": len(social_posts),
                "image_posts": 0,
                "video_posts": 0,
                "generated_images": 0,
                "generated_videos": 0,
                "brand_consistency": "Fallback mode",
                "platform_optimization": "Basic optimization"
            },
            "generation_metadata": {
                "agent_used": "FallbackVisualGenerator",
                "processing_time": 0.1,
                "quality_score": 5.0,
                "error": "Visual content generation failed"
            }
        }

# Export function for use in API routes
async def generate_visual_content_for_posts(
    social_posts: List[Dict[str, Any]], 
    business_context: Dict[str, Any],
    campaign_objective: str,
    target_platforms: List[str] = None
) -> Dict[str, Any]:
    """Convenience function for visual content generation."""
    orchestrator = VisualContentOrchestrator()
    return await orchestrator.generate_visual_content(
        social_posts, business_context, campaign_objective, target_platforms
    )

# Export functions for use in other modules
__all__ = [
    "generate_visual_content_for_posts"
] 